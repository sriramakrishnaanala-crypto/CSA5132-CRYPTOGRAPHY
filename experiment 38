#include <stdio.h>

// Find modular inverse of determinant
int modInverse(int a) {
    a %= 26;
    for(int x=1; x<26; x++)
        if((a*x)%26 == 1)
            return x;
    return -1;
}

// Recover key matrix
int main() {

    // Known plaintext matrix P
    int P[2][2] = {{7, 11},   // H=7, L=11
                   {8, 11}};  // I=8, L=11

    // Corresponding ciphertext matrix C
    int C[2][2] = {{19, 25},
                   {2,  23}};

    int det = (P[0][0]*P[1][1] - P[0][1]*P[1][0]) % 26;
    if(det < 0) det += 26;

    int det_inv = modInverse(det);

    if(det_inv == -1) {
        printf("Plaintext matrix not invertible.\n");
        return 0;
    }

    // Compute inverse of P
    int Pinv[2][2];

    Pinv[0][0] = ( P[1][1] * det_inv) % 26;
    Pinv[0][1] = (-P[0][1] * det_inv) % 26;
    Pinv[1][0] = (-P[1][0] * det_inv) % 26;
    Pinv[1][1] = ( P[0][0] * det_inv) % 26;

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            if(Pinv[i][j] < 0)
                Pinv[i][j] += 26;

    // Compute K = C * Pinv mod 26
    int K[2][2];

    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++) {
            K[i][j] = 0;
            for(int k=0;k<2;k++)
                K[i][j] += C[i][k] * Pinv[k][j];
            K[i][j] %= 26;
        }

    printf("Recovered Key Matrix:\n");
    for(int i=0;i<2;i++) {
        for(int j=0;j<2;j++)
            printf("%d ", K[i][j]);
        printf("\n");
    }

    return 0;
}
